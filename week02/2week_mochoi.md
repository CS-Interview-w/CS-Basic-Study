# 프로세스 vs 스레드

## 원준님이 보내주신 세부 주제

### 프로세스의 데이터 구조
#### 정적 할당 영역 - 코드 영역(code segment)
- 텍스트 영역(text segment)이라고도 불린다.
- 실행할 수 있는 코드. 기계어로 이루어진 명령어 저장
- 읽기 전용 공간(read-only)

#### 정적 할당 영역 - 데이터 영역(data segment)
- 프로그램이 실행되는 동안 유지할 데이터 저장
- 전역변수(global variable) 등

#### 동적 할당 영역 - 힙 영역(heap segment)
- 프로그래머가 직접 할당 및 반환하여 관리. 반환을 제대로 하지 않을 경우 메모리 누수(memoty leak)발생
- 낮은 주소 > 높은 주소

#### 동적 할당 영역 - 스택 영역(stack segment)
- 데이터 일시적으로 저장(PUSH)되고, 필요하지 않은 데이터는 사라지는(POP) 영역
- 매개 변수, 지역 변수
- 높은 주소 > 낮은 주소

### 컨텍스트 스위칭(context switching)
- 문맥 교환이라고 하며, 기존 프로세스의 문맥을 PCB 에 백업하고, 새로운 프로세슽를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
- 문맥 : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보


### Heap vs Stack
- stack 은 사용자가 관리하지 않는 차례로 데이터가 쌓이는 영역이며, heap 은 사용자가 직접 공간을 할당하고 반환하는 영역이다.

### JVM의 힙 메모리 ( => 가비지 컬렉터와 STW )
#### 가비지 컬렉터(Garbage Collector, GC) : 유효하지 않은 메모리 Garbage를 자동으로 정리해주는 것.
- java, kotlin 등은 메모리 누수를 방지하기 위해 가비지 컬렉가 주기적으로 검사하여 메모리를 청소해준다.
- java 는 명시적으로 불필요한 데이터를 표현하기 위해 일반적으로 null을 후에 할당해준다.
- JVM 영역은 대부분 객체는 금방 접근 불가능한 상태가 되며, 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다는 전제로 설계되었다. 이에 따라 객체의 생존 기간으로 물리적인 Heap 영역을 Young, Old 로 나누었다.
#### JVM의 힙 메모리 Young 영역, Old 영역 + 카드 테이블
- Young 영역 : 새롭게 생성된 객체가 할당되는 영역으로, 많은 객체가  생성되었다가 사라진다. 이 영역에 대한 GC를 Minor GC라고 부른다.
- Old 영역 : Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역이며, Young 영역보다 크게 할당된다. 또한, 영역 크기가 큰 만큼 가비지는 적게 발생한다. 이 영역에 대한 GC를 Major GC라고 부른다.
- 카드 테이블 : 드물게 Old 영역에 있는 객체가 Young 영역에 객체를 참조하는 경우도 존재할 것이다. 이러한 경우를 대비하여 Old 영역에는 512bytes 의 덩어리로 되어있는 카드 테이블이 존재한다.
Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 그에 대한 정보가 표시된다. 이 카드 테이블이 도입된 이유는 Toung 영역에서 Minor GC 가 실행될 때 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young 영역의 객체를 식별하는 것이 비효율적이기 떄문이다. 따라서 카드 테이블만 조회하여 GC대상인지 식별한다.

### 공유 자원과 동시성
#### 공유 자원(shared resource)
- 프로세스(또는 스레드)가 공동의 자원을 두고 작업할 때 이 공동의 자원을 뜻함.
#### 동시성(Concurrency)
- Task 들이 빠르게 전환하면서(Context Switching) 실행되어 동시에 실행되는 것처럼 보이는 것
- 싱글 코어에서도 동시적으로 실행 가능하며 독립적인 작업을 작은 단위 연산으로 나눠 시간 분할 형태로 연산하고, 유휴시간을 최소화하는 구조나 개념

#### 병렬성(Parallelism)
- 물리적인 시간에 작업을 동시에 수행하는 것
- 코어, 프로세스, 컴퓨터 등으로 동시에 수행할 수 있으며, 멀티 코어 한 개 이상의 스레드가 동시에 수행하는 것에 한정하는 것은 아니다.
- 메모리 손상, 누수 발생 가능

### 프로세스의 동기화 ( 뮤텍스, 세마포어, 모니터 )
#### 임계구역과 레이스 컨디션
- 임계구역(critical section) : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
- 레이스 컨디션(race condition) : 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우를 뜻함

#### 상호 배제를 위한 동기화
- 레이스 컨디션이 발생하지 않도록 2개 이상의 프로세스 또는 스레드가 임계구역에 동시에 접근하지 못하도록 관리하는 것

#### 동기화 원칙
- 운영체제는 임계구역 문제를 3가지 원칙 하에 해결한다.
- 상호 배제(mutual exclusion) : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
- 진행(process) : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- 유한 대기(bounded waiting) : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가 임계 구역에 들어올 수 있어야 한다.

### 불변객체와 무상태성
#### 불변객체(Immutable Object)란?
- 객체 생성 이후 내부의 상태가 변하지 않는 객체
- 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공
- 방어적 복사 : 참조를 통한 값의 수정을 막기 위해 내부를 복사하여 전달하는 것

#### 상태성과 무상태성
- 상태성 : 서버가 클라이언트의 이전 요청을 기억하는 것. 예로 FTP 가 있다.
- 무상태성 : 이전 요청과 현재 요청이 관계가 없고, 매 요청이 새롭다. 예로 HTTP 가 있다.
- 무상태성의 인증 관련의 비효율적인 문제를 해결하기 위하여 "쿠키"라는 기술이 등장

### [ 여기까지만 다루면 좋을 것 같아요, 아래는 참고 ]
### 자바의 synchronized 키워드
#### synchronized 키워드
- Java 에서는 뮤텍스와 세마포어의 한계를 극복하여 구현한 Monitor 를 제공하고, Java의 모든 인스턴스는 Object 내부에 구현도니 Monitor 를 가지고 있다.
- 동기화가 필요한 메서드나 멤버변수에 synchronized 키워드를 붙여주면 Monitor 를 활용하여 Java 내부적으로 상호배제가 이루어진다. 

### 싱글톤 패턴과 Lazy Holder, 원자적 연산
#### 추후 내용 추가 필요

## 원준님이 가르쳐준 내용
#### 추후 내용 추가 필요

## 참고 URL과 참고 파트
- JVM의 힙 메모리 : https://mangkyu.tistory.com/118
- 동시성, 병렬성 : https://velog.io/@wlsrhkd4023/%EB%8F%99%EC%8B%9C%EC%84%B1Concurrency%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1Parallelism-%EC%B0%A8%EC%9D%B4
- 불변객체란 : https://mangkyu.tistory.com/131
- 상태성과 무상태성 : https://fusiondeveloper.tistory.com/116
- 자바의 synchronized 키워드 : https://velog.io/@smallcherry/Java-Java%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95-1-synchronized-%ED%99%9C%EC%9A%A9

## 참고 문헌
- 혼자 공부하는 컴퓨터 구조 + 운영체제